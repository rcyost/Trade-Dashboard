{"timestamp": 1647711992.252199, "stored_source_code": "upstream = ['dataCollect'] # this means: execute raw.py, then clean.py\nproduct = None\n\nimport pandas as pd\nimport os\nimport numpy as np\nimport networkx as nx\n\n\nfrom networkx.algorithms.approximation.connectivity import node_connectivity\nfrom networkx.algorithms.bridges import has_bridges\nfrom networkx.algorithms.link_analysis.pagerank_alg import pagerank, pagerank_numpy\nfrom networkx.algorithms.approximation.connectivity import node_connectivity\nfrom networkx.algorithms.bridges import has_bridges\n\ndata=pd.read_csv(upstream['dataCollect']['DOTS'])\n\nkeepCols=['series_code', 'period', 'value', 'REF_AREA', 'INDICATOR', 'COUNTERPART_AREA', 'Reference Area', 'Counterpart Reference Area']\n\ncleanData = data[keepCols]\n# cleanData['INDICATOR'].unique()\n# cleanData['Reference Area'].unique()\n# cleanData['Counterpart Reference Area'].unique()\n\ncleanData.rename(columns={'Counterpart Reference Area':'CounterpartReferenceArea',\n        'Reference Area':'ReferenceArea'}, inplace=True)\n\n# drop groups\n# clean nan filled economies\n\nwideData = (cleanData\n    .pivot_table(\n        index=['period', 'CounterpartReferenceArea'],\n        columns='ReferenceArea',\n        values='value'))\n\n# remove groups\n# decided to keep 'Special Categories and Economic Zones' - sounds interesting\n# and wouldn't cause overlap to include i think\nremoveList = [\n'Export earnings: fuel',\n'Export earnings: nonfuel',\n'Middle East, North Africa, Afghanistan, and Pakistan',\n'Emerging and Developing Europe',\n'Western Hemisphere',\n'Western Hemisphere not allocated',\n'EU (Member States and Institutions of the European Union) changing composition',\n'Euro Area (Member States and Institutions of the Euro Area) changing composition',\n'Europe',\n'Europe not allocated',\n'Africa',\n'Africa not allocated',\n'Sub-Saharan Africa',\n'Middle East',\n'Middle East and Central Asia not specified',\n'Other Countries n.i.e. (IMF)',\n'Advanced Economies (IMF)',\n'Emerging and Developing Countries',\n'Developing Asia (IMF)',\n'Middle East and Central Asia',\n'Belgo-Luxembourg Economic Union',\n'Community of Independent States (CIS)',\n'Asia not allocated',\n'Former U.S.S.R.',\n'All Countries, excluding the IO']\n\n\ndataLong = (wideData\n    .melt(ignore_index=False)\n    .query('CounterpartReferenceArea not in @removeList')\n    .query('ReferenceArea not in @removeList')\n)\n\nprint(\"Lost: \", np.round((wideData.melt().shape[0] - dataLong.shape[0]) / wideData.melt().shape[0], 2) * 100, \"% rows due to dropping groups\")\n\nwideData2 = dataLong.pivot_table(index=['period', 'CounterpartReferenceArea'],\n                                columns='ReferenceArea',\n                                values='value')\n\ndataLong.reset_index(inplace=True)\ndataLong.rename(columns={'value':'weight'}, inplace=True)\n\n\n# #%%\n# # nans\n\n# colna = wideData2.isna().sum()\n# colna = colna / wideData2.shape[0]\n# colna.nlargest(20)\n\n# #%%\n# colna.nsmallest(20)\n\n\n\n\ndates = dataLong['period'].unique()\n\nstats=[]\nfor date in dates:\n\n    tempData=dataLong.query('period == @date')\n    tempData.dropna(axis=0, inplace=True)\n\n    G = nx.from_pandas_edgelist(df = tempData,\n                                        source = \"ReferenceArea\",\n                                        target = \"CounterpartReferenceArea\",\n                                        edge_attr = \"weight\",\n                                        create_using = nx.DiGraph())\n\n    tempdf = pd.DataFrame( dict(\n                    # key data\n                    # typf of graph\n                    #graphType = G.\n                    PERIOD = date,\n\n\n                    # --------------------------------MICRO\n\n                    ## ---- Centrality\n                    # returns a dict of node's degree\n                    DEGREE = dict(G.degree),\n                    IN_DEGREE = dict(G.in_degree),\n                    OUT_DEGREE = dict(G.out_degree),\n\n                    # fraction of nodes a node is connected to\n                    DEGREE_CENTRALITY = nx.degree_centrality(G),\n                    IN_DEGREE_CENTRALITY = nx.in_degree_centrality(G),\n                    OUT_DEGREE_CENTRALITY = nx.out_degree_centrality(G),\n                    AVG_NEIGHBOR_DEGREE = nx.average_neighbor_degree(G),\n\n                    # centrality based on importance of edges\n                    PAGERANK = pagerank(G, weight = 'weight'),\n                    PAGERANK_NUMPY = pagerank_numpy(G, weight = 'weight'),\n\n\n                    # centrality based on neighbors\n                    #EIGENVECTOR_CENTRAL = nx.eigenvector_centrality_numpy(G),\n                    # generalization of eigen centrality\n                    KATZ = nx.katz_centrality_numpy(G),\n                    CLOSENESS_CENTRALITY = nx.closeness_centrality(G),\n                    BETWEENNESS_CENTRALITY = nx.betweenness_centrality(G),\n\n                    ## ---- Paths\n\n                    ## ---- Clustering\n                    # node clustering scores\n                    CLUSTCOEF = nx.clustering(G),\n\n\n\n                    #-----------------------------------MACRO\n                    ##  --- Size\n                    NUM_NODES = G.number_of_nodes(),\n                    NUM_EDGES = G.number_of_edges(),\n                    TOTAL_NET_VALUE = tempData['weight'].sum(),\n\n                    ## ----- Connectivity\n                    CONNECTIVITY = node_connectivity(G),\n\n                    # edge whose removal causes the number of connected components of the graph to increase\n                    HAS_BRIDGE = has_bridges(nx.Graph(G)),\n\n                    ## ---- Clustering\n                    # ego net clusterting score\n                    # graph clustering score\n                    AVERAGECLUSTCOEF = nx.average_clustering(G),\n                    TRIANGLES = nx.triangles(nx.Graph(G)),\n\n                ))\n\n    stats.append(tempdf)\n    # print(date)\n\n\nstatDF = pd.concat(stats)\nstatDF.reset_index(inplace=True)\nstatDF.to_csv(str(product['DOTSnetStats']))", "params": {}}